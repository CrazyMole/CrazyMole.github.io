<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Language on xy1m</title>
    <link>https://crazymole.github.io/tags/language/</link>
    <description>Recent content in Language on xy1m</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Powered by [Hugo](http://gohugo.io).</copyright>
    <lastBuildDate>Mon, 21 Mar 2016 14:32:43 -0400</lastBuildDate>
    <atom:link href="https://crazymole.github.io/tags/language/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python 2 Basic</title>
      <link>https://crazymole.github.io/post/Python-Basic/</link>
      <pubDate>Mon, 21 Mar 2016 14:32:43 -0400</pubDate>
      
      <guid>https://crazymole.github.io/post/Python-Basic/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简
单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上
解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语
言，特别适用于快速的应用程序开发。&lt;/p&gt;

&lt;p&gt;Python语言的创造者Guido van Rossum是根据英国广播公司的节目“蟒蛇飞行马戏”命名这个语言的，并非他本人特别喜欢蛇缠起它们的长身躯碾死动物觅食&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单

&lt;ul&gt;
&lt;li&gt;Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;易学

&lt;ul&gt;
&lt;li&gt;就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;免费，开源

&lt;ul&gt;
&lt;li&gt;Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;高层语言

&lt;ul&gt;
&lt;li&gt;当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可移植

&lt;ul&gt;
&lt;li&gt;由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解释性

&lt;ul&gt;
&lt;li&gt;一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码 运行 程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;面向对象

&lt;ul&gt;
&lt;li&gt;Python即支持面向过程的编程也支持面向对象的编程。在 面向过程 的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在 面向对象 的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可扩展性

&lt;ul&gt;
&lt;li&gt;如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可嵌入性

&lt;ul&gt;
&lt;li&gt;你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;丰富的库

&lt;ul&gt;
&lt;li&gt;Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装python&#34;&gt;安装Python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help(命令)&lt;/code&gt; 获取帮助&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;# 注释&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Python 区分大小写&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字面意义常量&#34;&gt;字面意义常量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;字面具有意义，无法改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4种数-整数-长整数-浮点数-复数&#34;&gt;4种数&amp;ndash;整数，长整数，浮点数，复数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2是整数&lt;/li&gt;
&lt;li&gt;长整数不过是大一点的整数&lt;/li&gt;
&lt;li&gt;3.23和52.3E-4是浮点数，E表示10的幂&lt;/li&gt;
&lt;li&gt;(-5+4j)(2.3-4.6j)是复数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;单引号，双引号&lt;/li&gt;
&lt;li&gt;三引号可以指示多行字符串，其中自由使用单引号和双引号&lt;/li&gt;
&lt;li&gt;特殊字符用转义符&lt;/li&gt;
&lt;li&gt;反斜杠在结尾表示下一行继续，而不是新开始一行&lt;/li&gt;
&lt;li&gt;自然字符串，不需要转义符特殊处理 r[R]&amp;ldquo;hello&amp;rdquo;&lt;/li&gt;
&lt;li&gt;unicode字符串 u[U]&amp;ldquo;hello&amp;rdquo;&lt;/li&gt;
&lt;li&gt;字符串不可变&lt;/li&gt;
&lt;li&gt;字面意义连级字符串 &amp;lsquo;Hello&amp;rdquo;World&amp;rsquo;==&amp;lsquo;Hello World&amp;rsquo;&lt;/li&gt;
&lt;li&gt;没有char类型&lt;/li&gt;
&lt;li&gt;正则用自然字符串处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;变量首字符是字母或下划线&lt;/li&gt;
&lt;li&gt;其他部分可以是数字&lt;/li&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;数据类型 数，字符串，类&lt;/li&gt;
&lt;li&gt;不需要声明定义数据类型，直接赋值&lt;/li&gt;
&lt;li&gt;物理行是人看到的，逻辑行是Python看到的，默认Python希望一行处理一个语句，代码易读，如果物理行多余一个逻辑，使用分号，使用反斜杠是明确连接行为，圆括号，方括号，花括号是暗示连接，不需要反斜杠&lt;/li&gt;
&lt;li&gt;缩进代表层次，1个TAB或者2个或者4个空格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;运算符和表达式&#34;&gt;运算符和表达式&lt;/h2&gt;

&lt;h3 id=&#34;运算符&#34;&gt;运算符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;*两数相乘或者得到若干次数字符串&lt;/li&gt;
&lt;li&gt;/得到浮点数&lt;/li&gt;
&lt;li&gt;//整除&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;左移&amp;gt;&amp;gt;右移&lt;/li&gt;
&lt;li&gt;~按位反转 x按位反转 -(x+1) ~5=-6&lt;/li&gt;
&lt;li&gt;not and or 非，与，或 True False&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从左向右计算，从右向左赋值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;控制流&#34;&gt;控制流&lt;/h2&gt;

&lt;p&gt;控制流语句后面加:表示下面跟着一个语句块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if elseif else&lt;/li&gt;
&lt;li&gt;while 可接 else&lt;/li&gt;
&lt;li&gt;for 可接 else&lt;/li&gt;
&lt;li&gt;range生成序列，range(n)代表[0,n-1]，range(x,y)代表[x,y-1],range(x,y,z) z代表步长&lt;/li&gt;
&lt;li&gt;使用break后else不执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;形参&lt;/li&gt;
&lt;li&gt;局部变量作用范围是声明的代码块&lt;/li&gt;
&lt;li&gt;golbal变量是全局的 可以指定多个变量 global x,y,z&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def func():
  global x
  print &#39;x is&#39;,x
  x=2
  print &#39;changed global x to&#39;,x
x=50
func()
print &#39;Value of x is&#39;,x

$ python func_global.py
x is 50
changed global x to 2
Value of x is 2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;默认参数&lt;code&gt;def say(message, times=1)&lt;/code&gt; 只有形参末尾参数可以有默认参数&lt;/li&gt;
&lt;li&gt;关键参数通过命名给参数赋值&lt;code&gt;func(c=50,a=100)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;return 跳出参数 或者 返回值&lt;/li&gt;
&lt;li&gt;pass 代表空语句块&lt;/li&gt;
&lt;li&gt;没有返回值的return语句相当于 return None&lt;/li&gt;
&lt;li&gt;文档字符串 DocString，适用于函数，模块，类，强烈建议有并且按照规范写&lt;/li&gt;
&lt;li&gt;DocString按惯例是一个多行字符串，首行大写字母开始，句号结尾，第二行空行，第三行详细描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__doc__&lt;/code&gt;文档字符串属性，help抓取函数&lt;code&gt;__doc__&lt;/code&gt;属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;模块&#34;&gt;模块&lt;/h2&gt;

&lt;p&gt;模块基本是包含所有你定义的函数和变量的文件，以便重用，必须.py扩展名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: using_sys.py
import sys
print &#39;The command line arguments are:&#39;
for i in sys.argv:
print i
print &#39;\n\nThe PYTHONPATH is&#39;, sys.path, &#39;\n&#39;

$ python using_sys.py we are arguments
The command line arguments are:
using_sys.py
we
are
arguments
The PYTHONPATH is [&#39;/home/swaroop/byte/code&#39;, &#39;/usr/lib/python23.zip&#39;,
&#39;/usr/lib/python2.3&#39;, &#39;/usr/lib/python2.3/plat-linux2&#39;,
&#39;/usr/lib/python2.3/lib-tk&#39;, &#39;/usr/lib/python2.3/lib-dynload&#39;,
&#39;/usr/lib/python2.3/site-packages&#39;, &#39;/usr/lib/python2.3/site-packages/gtk-2.0&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当Python执行import sys语句的时候，它在sys.path变量中所列目录中寻找sys.py模块。如果找到
了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你使用.初
始化过程仅在我们第一次输入模块的时候进行.脚本的名称总是sys.argv列表的第一个参数.
sys.path包含输入模块的目录名列表。我们可以观察到sys.path的第一个字符串是空的,这个
空的字符串表示当前目录也是sys.path的一部分，这与PYTHONPATH环境变量是相同的。这意
味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在sys.path所列的目录之
一。&lt;/p&gt;

&lt;h3 id=&#34;字节编译的-pyc文件&#34;&gt;字节编译的.pyc文件&lt;/h3&gt;

&lt;p&gt;输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更
加快一些。一种方法是创建字节编译的文件,这些文件以.pyc作为扩展名。字节编译的文件与
Python变换程序的中间状态有关,当你在下次从别的程序输入这个模块的时候,.pyc文件是十分有用的——它会快得多,因为一部分输入模块所需
的处理已经完成了,这些字节编译的文件也是与平台无关的。&lt;/p&gt;

&lt;h3 id=&#34;from-import&#34;&gt;from..import&lt;/h3&gt;

&lt;p&gt;如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用
from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys
import *语句。这对于所有模块都适用。一般说来，应该避免使用from..import而使用import语
句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。&lt;/p&gt;

&lt;h3 id=&#34;模块的-name&#34;&gt;模块的&lt;code&gt;__name__&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;python 模块有它的&lt;code&gt;__name__&lt;/code&gt;，如果是&lt;code&gt;__main__&lt;/code&gt;，说明被单独运行。&lt;/p&gt;

&lt;h3 id=&#34;制造自己模块&#34;&gt;制造自己模块&lt;/h3&gt;

&lt;p&gt;模块放在输入它的程序同一个目录或者sys.path之一。&lt;/p&gt;

&lt;h3 id=&#34;dir-函数&#34;&gt;dir()函数&lt;/h3&gt;

&lt;p&gt;你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。
当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当
前模块中定义的名称列表。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;3种内建数据结构，列表，元组，字典&lt;/li&gt;
&lt;li&gt;列表，逗号分隔，可添加，删除，搜索，相当于链表[&amp;lsquo;apple&amp;rsquo;,&amp;lsquo;mac&amp;rsquo;]&lt;/li&gt;
&lt;li&gt;for..in用来遍历序列，del删除元素&lt;/li&gt;
&lt;li&gt;元组和列表类似，但是不能修改，相当于数组(&amp;lsquo;Java&amp;rsquo;,&amp;lsquo;Python&amp;rsquo;)&lt;/li&gt;
&lt;li&gt;元组最通常用在打印中&lt;code&gt;print &#39;%s is %d years old&#39; % (name, age)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字典相当于Map，键值对{key:value,key1:value1} 无序，想要顺序，使用前排序&lt;/li&gt;
&lt;li&gt;in检验键值是否存在，或者使用dict类的has_key，items()返回元组列表，每个元组包含一对项目，键值对&lt;/li&gt;
&lt;li&gt;列表，元组，字符串都是序列，具有索引和切片操作，索引获取特定项目，切片获取序列一部分&lt;/li&gt;
&lt;li&gt;索引负数表示从序列结尾计算，apple[-1]表示最后一个元素&lt;/li&gt;
&lt;li&gt;切片是序列名后跟方括号，方括号中一对可选数字，冒号分隔，数可选，冒号必须&lt;/li&gt;
&lt;li&gt;第一个数字开始位置，第二个数结束位置，不指定第一个数，从序列首开始，不指定第二个参数，序列尾结束，开始位置包含在切片，结束位置不包含&lt;/li&gt;
&lt;li&gt;注意引用，复制列表或者类似的序列，使用切片操作取得拷贝&lt;/li&gt;
&lt;li&gt;列表赋值不是创建拷贝，需要使用切片建立序列拷贝&lt;/li&gt;
&lt;li&gt;字符串方法 &lt;code&gt;&amp;quot;apple&amp;quot;.startswith(&amp;quot;a&amp;quot;)==True,&#39;a&#39; in &amp;quot;apple&amp;quot;==True,&amp;quot;apple&amp;quot;.find(a)==0,&amp;quot;-&amp;quot;.join([&amp;quot;Hello&amp;quot;,&amp;quot;World&amp;quot;])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编写python脚本&#34;&gt;编写Python脚本&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: backup_ver4.py
import os
import time
# 1. The files and directories to be backed up are specified in a list.
source = [&#39;/home/swaroop/byte&#39;, &#39;/home/swaroop/bin&#39;]
# If you are using Windows, use source = [r&#39;C:\Documents&#39;, r&#39;D:\Work&#39;] or something like that
# 2. The backup must be stored in a main backup directory
target_dir = &#39;/mnt/e/backup/&#39; # Remember to change this to what you will be using
# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory in the main directory
today = target_dir + time.strftime(&#39;%Y%m%d&#39;)
# The current time is the name of the zip archive
now = time.strftime(&#39;%H%M%S&#39;)
# Take a comment from the user to create the name of the zip file
comment = raw_input(&#39;Enter a comment --&amp;gt; &#39;)
if len(comment) == 0: # check if a comment was entered
target = today + os.sep + now + &#39;.zip&#39;
else:
target = today + os.sep + now + &#39;_&#39; + \
comment.replace(&#39; &#39;, &#39;_&#39;) + &#39;.zip&#39;
# Notice the backslash!
# Create the subdirectory if it isn&#39;t already there
if not os.path.exists(today):
os.mkdir(today) # make directory
print &#39;Successfully created directory&#39;, today
# 5. We use the zip command (in Unix/Linux) to put the files in a zip archive
zip_command = &amp;quot;zip -qr &#39;%s&#39; %s&amp;quot; % (target, &#39; &#39;.join(source))
# Run the backup
if os.system(zip_command) == 0:
print &#39;Successful backup to&#39;, target
else:
print &#39;Backup FAILED&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;面向对象编程&#34;&gt;面向对象编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;成员变量叫域，成员方法叫类的方法,域分为实例变量和类变量&lt;/li&gt;
&lt;li&gt;class 关键字创建，域和方法在一个缩进块中&lt;/li&gt;
&lt;li&gt;类方法和函数只有一个区别，必须有额外第一个参数名称，调用不用赋值，python自动赋值，对象本身self&lt;/li&gt;
&lt;li&gt;self相当于this&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.method(arg1,arg2) class.method(obj,arg1,arg2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__&lt;/code&gt;相当于constructor&lt;/li&gt;
&lt;li&gt;类变量所有实例共享，对象变量对象私有，self变量参考对象变量和方法，称为属性参考&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__&lt;/code&gt;相当于析构函数&lt;/li&gt;
&lt;li&gt;所有类成员，数据成员和方法都是public的，双下划线前缀为private&lt;/li&gt;
&lt;li&gt;惯例 只想在类或对象中使用，单下划线前缀&lt;/li&gt;
&lt;li&gt;继承 基本诶名称作为元组跟在定义类名称之后，基本类的&lt;code&gt;__init__&lt;/code&gt;使用self调用，这样就可以初始化对象的基本类部分，python不会自动调用基本类的constructor&lt;/li&gt;
&lt;li&gt;继承元组中使用一个以上的类称作多重继承&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;输入输出&#34;&gt;输入输出&lt;/h2&gt;

&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;

&lt;p&gt;使用File类的read，readline和write方法读写文件，对文件的读写能力依赖于开发文件的模式，完成文件操作，调用close&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: using_file.py
poem = &#39;&#39;&#39;\
Programming is fun
When the work is done
if you wanna make your work also fun:
use Python!
&#39;&#39;&#39;
f = file(&#39;poem.txt&#39;, &#39;w&#39;) # open for &#39;w&#39;riting
f.write(poem) # write text to file
f.close() # close the file
f = file(&#39;poem.txt&#39;)
# if no mode is specified, &#39;r&#39;ead mode is assumed by default
while True:
line = f.readline()
if len(line) == 0: # Zero length indicates EOF
break
print line,
# Notice comma to avoid automatic newline added by Python
f.close() # close the file
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;r读模式，w写模式，a追加模式&lt;/li&gt;
&lt;li&gt;len(f.readline())==0 indicates EOF&lt;/li&gt;
&lt;li&gt;,消除换行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;存储器&#34;&gt;存储器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python标准模块，称为pickle，在文件中存储Python对象，之后可以取出来。相当于Java中的持久化&lt;/li&gt;
&lt;li&gt;cPickle功能一致，用c编写的，更快&lt;/li&gt;
&lt;li&gt;import..as 可以使用更短模块名称&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: pickling.py
import cPickle as p
#import pickle as p
shoplistfile = &#39;shoplist.data&#39;
# the name of the file where we will store the object
shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;]
# Write to the file
f = file(shoplistfile, &#39;w&#39;)
p.dump(shoplist, f) # dump the object to a file
f.close()
del shoplist # remove the shoplist
# Read back from the storage
f = file(shoplistfile)
storedlist = p.load(f)
print storedlist
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;

&lt;h3 id=&#34;try-except&#34;&gt;try..except&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: try_except.py
import sys
try:
s = raw_input(&#39;Enter something --&amp;gt; &#39;)
except EOFError:
print &#39;\nWhy did you do an EOF on me?&#39;
sys.exit() # exit the program
except:
print &#39;\nSome error/exception occurred.&#39;
# here, we are not exiting the program
print &#39;Done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try..except相当于Java中的try exception&lt;/li&gt;
&lt;li&gt;可以接else语句，没有异常时执行&lt;/li&gt;
&lt;li&gt;raise引发异常，相当于throw，指明名称和异常对象，Error或者Exception的子类&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: raising.py
class ShortInputException(Exception):
&#39;&#39;&#39;A user-defined exception class.&#39;&#39;&#39;
def __init__(self, length, atleast):
Exception.__init__(self)
self.length = length
self.atleast = atleast
try:
s = raw_input(&#39;Enter something --&amp;gt; &#39;)
if len(s) &amp;lt; 3:
raise ShortInputException(len(s), 3)
# Other work can continue as usual here
except EOFError:
print &#39;\nWhy did you do an EOF on me?&#39;
except ShortInputException, x:
print &#39;ShortInputException: The input was of length %d, \
was expecting at least %d&#39; % (x.length, x.atleast)
else:
print &#39;No exception was raised.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;try-finally&#34;&gt;try..finally&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: finally.py
import time
try:
f = file(&#39;poem.txt&#39;)
while True: # our usual file-reading idiom
line = f.readline()
if len(line) == 0:
break
time.sleep(2)
print line,
finally:
f.close()
print &#39;Cleaning up...closed the file&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python标准库&#34;&gt;Python标准库&lt;/h2&gt;

&lt;h3 id=&#34;sys模块&#34;&gt;sys模块&lt;/h3&gt;

&lt;p&gt;sys模块包含系统对应功能, sys.stdin,sys.stdout,sys.stderr对应标准输入，输出，错误流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: cat.py
import sys
def readfile(filename):
&#39;&#39;&#39;Print a file to the standard output.&#39;&#39;&#39;
f = file(filename)
while True:
line = f.readline()
if len(line) == 0:
break
print line, # notice comma
f.close()
# Script starts from here
if len(sys.argv) &amp;lt; 2:
print &#39;No action specified.&#39;
sys.exit()
if sys.argv[1].startswith(&#39;--&#39;):
option = sys.argv[1][2:]
# fetch sys.argv[1] but without the first two characters
if option == &#39;version&#39;:
print &#39;Version 1.2&#39;
elif option == &#39;help&#39;:
print &#39;&#39;&#39;\
This program prints files to the standard output.
Any number of files can be specified.
Options include:
--version : Prints the version number
--help : Display this help&#39;&#39;&#39;
else:
print &#39;Unknown option.&#39;
sys.exit()
else:
for filename in sys.argv[1:]:
readfile(filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os模块&#34;&gt;os模块&lt;/h3&gt;

&lt;p&gt;包含普遍操作系统功能，对平台无关很重要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;os.name windows-&amp;gt;nt,linux/unix-&amp;gt;posix&lt;/li&gt;
&lt;li&gt;os.getcwd() 当前工作目录&lt;/li&gt;
&lt;li&gt;os.getenv(),os.putenv()读取和设置环境变量&lt;/li&gt;
&lt;li&gt;os.listdir()返回指定目录下的所有文件和目录名&lt;/li&gt;
&lt;li&gt;os.remove()删除文件&lt;/li&gt;
&lt;li&gt;os.system()运行shell命令&lt;/li&gt;
&lt;li&gt;os.linesep当前平台终止符&lt;/li&gt;
&lt;li&gt;os.path.split()返回目录名和文件名&lt;code&gt;os.path.split(&#39;/home/apple.txt&#39;)-&amp;gt;(&#39;/home&#39;,&#39;apple.txt&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;os.path.isfile() os.path.isdir()判断文件和路径&lt;/li&gt;
&lt;li&gt;os.path.exists()判断路径是否存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;更多python内容&#34;&gt;更多Python内容&lt;/h2&gt;

&lt;h3 id=&#34;特殊方法&#34;&gt;特殊方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__(self...)&lt;/code&gt; 新建对象调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__(self)&lt;/code&gt; 删除对象调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__str__(self)&lt;/code&gt; print语句或者str()调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__lt__(self,other)&lt;/code&gt; 运算符&amp;lt;调用，类似+&amp;gt;都有特殊方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__getitem__(self,key)&lt;/code&gt;使用x[key]索引操作符调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__len(self)__&lt;/code&gt;内建len()函数调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;单语句块&#34;&gt;单语句块&lt;/h3&gt;

&lt;p&gt;语句块只包含一句，可以在条件或者循环语句同一行指明&lt;/p&gt;

&lt;h3 id=&#34;列表综合&#34;&gt;列表综合&lt;/h3&gt;

&lt;p&gt;从已有列表导出一个新的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: list_comprehension.py
listone = [2, 3, 4]
listtwo = [2*i for i in listone if i &amp;gt; 2]
print listtwo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数中接收元组和列表&#34;&gt;函数中接收元组和列表&lt;/h3&gt;

&lt;p&gt;使用函数接受元组或者字典参数，可以加*和**前缀
由于args变量前有*前缀，多余参数会作为元组存储在args上，如果使用的是**前缀，多余参数被认为是字典的键值对&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def powersum(power, *args):
... &#39;&#39;&#39;Return the sum of each argument raised to specified power.&#39;&#39;&#39;
... total = 0
... for i in args:
... total += pow(i, power)
... return total
...
&amp;gt;&amp;gt;&amp;gt; powersum(2, 3, 4)
25
&amp;gt;&amp;gt;&amp;gt; powersum(2, 10)
100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda形式&#34;&gt;lambda形式&lt;/h3&gt;

&lt;p&gt;lambda用来创建新的函数对象，运行时返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: lambda.py
def make_repeater(n):
return lambda s: s*n
twice = make_repeater(2)
print twice(&#39;word&#39;)
print twice(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exec-和-eval&#34;&gt;exec 和 eval&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;exec用来执行字符串或者文件中的python语句&lt;/li&gt;
&lt;li&gt;eval 用来计算存储在字符串中的有效python表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;assert&#34;&gt;assert&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;和Java类似，assert验证某个条件为真，如果为假，触发AssertError&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;repr函数&#34;&gt;repr函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;取得对象的规范字符串表示，`完成相同功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接下来学什么&#34;&gt;接下来学什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Python标准库是一个丰富的库，在大多数时候，你可以在这个库中找到你所需的东西。
这被称为Python的“功能齐全”理念。我强烈建议你在开始开发大型Python程序之前浏
览一下Python标准文档。&lt;/li&gt;
&lt;li&gt;Python.org——Python编程语言的官方主页。你可以在上面找到Python语言和解释器的最
新版本。另外还有各种邮件列表活跃地讨论Python的各方面内容。&lt;/li&gt;
&lt;li&gt;comp.lang.python是讨论Python语言的世界性新闻组。你可以把你的疑惑和询问贴在这个
新闻组上。可以使用Google群在线访问这个新闻组，或加入作为新闻组镜像的邮件列
表。&lt;/li&gt;
&lt;li&gt;《Python实用大全》是一个极有价值的秘诀和技巧集合，它帮助你解决某些使用Python
的问题。这是每个Python用户必读的一本书。&lt;/li&gt;
&lt;li&gt;《迷人的Python》是David Mertz编著的一系列优秀的Python相关文章。&lt;/li&gt;
&lt;li&gt;《深入理解Python》是给有经验的Python程序员的一本很优秀的书。如果你已经完整地
阅读了本书，那么我强烈建议你接下来阅读《深入理解Python》。它覆盖了包括XML处
理、单元测试和功能性编程在内的广泛的主题。&lt;/li&gt;
&lt;li&gt;Jython是用Java语言实现的Python解释器。这意味着你可以用Python语言编写程序而同时
使用Java库！Jython是一个稳定成熟的软件。如果你也是一个Java程序员，我强烈建议你
尝试一下Jython。&lt;/li&gt;
&lt;li&gt;IronPython是用C#语言实现的Python解释器，可以运行在.NET、Mono和DotGNU平台
上。这意味着你可以用Python语言编写程序而使用.NET库以及其他由这三种平台提供的
库！IronPython还只是一个前期alpha测试软件，现在还只适合用来进行试验。Jim
Hugunin，IronPython的开发者，已经加入了微软公司，将在将来全力开发一个完整版本
的IronPython。&lt;/li&gt;
&lt;li&gt;Lython是Python语言的Lisp前段。它类似于普通的Lisp语言，会被直接编译为Python字节码，这意味着它能与我们普通的Python代码协同工作。&lt;/li&gt;
&lt;li&gt;另外还有很多很多的Python资源。其中比较有趣的有Daily Python-URL!，它使你保持与Python的最新进展同步。另外还有Vaults of Parnassus、ONLamp.com Python DevCenter、dirtSimple.org、Python Notes等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;《Python简明教程》&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>