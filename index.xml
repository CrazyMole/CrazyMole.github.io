<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xy1m</title>
    <link>https://crazymole.github.io/</link>
    <description>Recent content on xy1m</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Powered by [Hugo](http://gohugo.io).</copyright>
    <lastBuildDate>Mon, 01 Aug 2016 18:20:14 -0700</lastBuildDate>
    <atom:link href="https://crazymole.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Xor sequence</title>
      <link>https://crazymole.github.io/post/Xor-sequence/</link>
      <pubDate>Mon, 01 Aug 2016 18:20:14 -0700</pubDate>
      
      <guid>https://crazymole.github.io/post/Xor-sequence/</guid>
      <description>&lt;p&gt;We can easily find a pattern &lt;code&gt;F(n)=0^1^...^n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So for &lt;code&gt;F(L)^F(L+1)^...^F(R)&lt;/code&gt; should look like below&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;F(L)=0^...^L;
F(L+1)=0^...^L^(L+1);
F(L+2)=0^...^L^(L+1)^L(+2);
...
F(R)=0^...^L^(L+1)^(L+2)...^R;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is another import pattern that every 4 odd xor is 0, and every 4 even xor is also 0, R is always in the formula because it only appears once, so is (R-2) appear 3 times and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Guess what?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If (R-L+1) is odd, then result is &lt;code&gt;0^1^...^L^(L+2)^(L+4)^...^R&lt;/code&gt;,that&amp;rsquo;s &lt;code&gt;0^...^(L-2)^L^(L+2)^...^R&lt;/code&gt;^&lt;code&gt;0^...^(L-3)^(L-1)&lt;/code&gt;,
else &lt;code&gt;(L+1)^(L+3)^...^R&lt;/code&gt;, that&amp;rsquo;s &lt;code&gt;0^...^(L-1)^(L+1)^...R&lt;/code&gt;^&lt;code&gt;0^...^(L-1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We define a function xor2(I really don&amp;rsquo;t good at naming &lt;code&gt;:(&lt;/code&gt;) means how many numbers(who are with same parity) with N then %4 and then calculate the result, we don&amp;rsquo;t care about the parity of L or R, so the result should be &lt;code&gt;xor2(R)^xor2(L-1)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int Q = in.nextInt();
        StringBuilder sb=new StringBuilder();
        for(int a0 = 0; a0 &amp;lt; Q; a0++){
            long L = in.nextLong();
            long R = in.nextLong();
            sb.append(xor2(R)^xor2(L-1)).append(&amp;quot;\n&amp;quot;);
        }
        System.out.println(sb.toString());
    }
    
    public static long xor2(long n){
        long res=0;
        for(int i=0;i&amp;lt;(n+1)%8;i+=2){
            res^=n-i;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python 2 Basic</title>
      <link>https://crazymole.github.io/post/Python-Basic/</link>
      <pubDate>Mon, 21 Mar 2016 14:32:43 -0400</pubDate>
      
      <guid>https://crazymole.github.io/post/Python-Basic/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简
单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上
解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语
言，特别适用于快速的应用程序开发。&lt;/p&gt;

&lt;p&gt;Python语言的创造者Guido van Rossum是根据英国广播公司的节目“蟒蛇飞行马戏”命名这个语言的，并非他本人特别喜欢蛇缠起它们的长身躯碾死动物觅食&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单

&lt;ul&gt;
&lt;li&gt;Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;易学

&lt;ul&gt;
&lt;li&gt;就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;免费，开源

&lt;ul&gt;
&lt;li&gt;Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;高层语言

&lt;ul&gt;
&lt;li&gt;当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可移植

&lt;ul&gt;
&lt;li&gt;由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解释性

&lt;ul&gt;
&lt;li&gt;一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码 运行 程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;面向对象

&lt;ul&gt;
&lt;li&gt;Python即支持面向过程的编程也支持面向对象的编程。在 面向过程 的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在 面向对象 的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可扩展性

&lt;ul&gt;
&lt;li&gt;如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可嵌入性

&lt;ul&gt;
&lt;li&gt;你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;丰富的库

&lt;ul&gt;
&lt;li&gt;Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装python&#34;&gt;安装Python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://python.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help(命令)&lt;/code&gt; 获取帮助&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;# 注释&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Python 区分大小写&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字面意义常量&#34;&gt;字面意义常量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;字面具有意义，无法改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4种数-整数-长整数-浮点数-复数&#34;&gt;4种数&amp;ndash;整数，长整数，浮点数，复数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2是整数&lt;/li&gt;
&lt;li&gt;长整数不过是大一点的整数&lt;/li&gt;
&lt;li&gt;3.23和52.3E-4是浮点数，E表示10的幂&lt;/li&gt;
&lt;li&gt;(-5+4j)(2.3-4.6j)是复数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;单引号，双引号&lt;/li&gt;
&lt;li&gt;三引号可以指示多行字符串，其中自由使用单引号和双引号&lt;/li&gt;
&lt;li&gt;特殊字符用转义符&lt;/li&gt;
&lt;li&gt;反斜杠在结尾表示下一行继续，而不是新开始一行&lt;/li&gt;
&lt;li&gt;自然字符串，不需要转义符特殊处理 r[R]&amp;ldquo;hello&amp;rdquo;&lt;/li&gt;
&lt;li&gt;unicode字符串 u[U]&amp;ldquo;hello&amp;rdquo;&lt;/li&gt;
&lt;li&gt;字符串不可变&lt;/li&gt;
&lt;li&gt;字面意义连级字符串 &amp;lsquo;Hello&amp;rdquo;World&amp;rsquo;==&amp;lsquo;Hello World&amp;rsquo;&lt;/li&gt;
&lt;li&gt;没有char类型&lt;/li&gt;
&lt;li&gt;正则用自然字符串处理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;变量首字符是字母或下划线&lt;/li&gt;
&lt;li&gt;其他部分可以是数字&lt;/li&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;数据类型 数，字符串，类&lt;/li&gt;
&lt;li&gt;不需要声明定义数据类型，直接赋值&lt;/li&gt;
&lt;li&gt;物理行是人看到的，逻辑行是Python看到的，默认Python希望一行处理一个语句，代码易读，如果物理行多余一个逻辑，使用分号，使用反斜杠是明确连接行为，圆括号，方括号，花括号是暗示连接，不需要反斜杠&lt;/li&gt;
&lt;li&gt;缩进代表层次，1个TAB或者2个或者4个空格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;运算符和表达式&#34;&gt;运算符和表达式&lt;/h2&gt;

&lt;h3 id=&#34;运算符&#34;&gt;运算符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;*两数相乘或者得到若干次数字符串&lt;/li&gt;
&lt;li&gt;/得到浮点数&lt;/li&gt;
&lt;li&gt;//整除&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;左移&amp;gt;&amp;gt;右移&lt;/li&gt;
&lt;li&gt;~按位反转 x按位反转 -(x+1) ~5=-6&lt;/li&gt;
&lt;li&gt;not and or 非，与，或 True False&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从左向右计算，从右向左赋值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;控制流&#34;&gt;控制流&lt;/h2&gt;

&lt;p&gt;控制流语句后面加:表示下面跟着一个语句块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if elseif else&lt;/li&gt;
&lt;li&gt;while 可接 else&lt;/li&gt;
&lt;li&gt;for 可接 else&lt;/li&gt;
&lt;li&gt;range生成序列，range(n)代表[0,n-1]，range(x,y)代表[x,y-1],range(x,y,z) z代表步长&lt;/li&gt;
&lt;li&gt;使用break后else不执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;形参&lt;/li&gt;
&lt;li&gt;局部变量作用范围是声明的代码块&lt;/li&gt;
&lt;li&gt;golbal变量是全局的 可以指定多个变量 global x,y,z&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def func():
  global x
  print &#39;x is&#39;,x
  x=2
  print &#39;changed global x to&#39;,x
x=50
func()
print &#39;Value of x is&#39;,x

$ python func_global.py
x is 50
changed global x to 2
Value of x is 2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;默认参数&lt;code&gt;def say(message, times=1)&lt;/code&gt; 只有形参末尾参数可以有默认参数&lt;/li&gt;
&lt;li&gt;关键参数通过命名给参数赋值&lt;code&gt;func(c=50,a=100)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;return 跳出参数 或者 返回值&lt;/li&gt;
&lt;li&gt;pass 代表空语句块&lt;/li&gt;
&lt;li&gt;没有返回值的return语句相当于 return None&lt;/li&gt;
&lt;li&gt;文档字符串 DocString，适用于函数，模块，类，强烈建议有并且按照规范写&lt;/li&gt;
&lt;li&gt;DocString按惯例是一个多行字符串，首行大写字母开始，句号结尾，第二行空行，第三行详细描述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__doc__&lt;/code&gt;文档字符串属性，help抓取函数&lt;code&gt;__doc__&lt;/code&gt;属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;模块&#34;&gt;模块&lt;/h2&gt;

&lt;p&gt;模块基本是包含所有你定义的函数和变量的文件，以便重用，必须.py扩展名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: using_sys.py
import sys
print &#39;The command line arguments are:&#39;
for i in sys.argv:
print i
print &#39;\n\nThe PYTHONPATH is&#39;, sys.path, &#39;\n&#39;

$ python using_sys.py we are arguments
The command line arguments are:
using_sys.py
we
are
arguments
The PYTHONPATH is [&#39;/home/swaroop/byte/code&#39;, &#39;/usr/lib/python23.zip&#39;,
&#39;/usr/lib/python2.3&#39;, &#39;/usr/lib/python2.3/plat-linux2&#39;,
&#39;/usr/lib/python2.3/lib-tk&#39;, &#39;/usr/lib/python2.3/lib-dynload&#39;,
&#39;/usr/lib/python2.3/site-packages&#39;, &#39;/usr/lib/python2.3/site-packages/gtk-2.0&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当Python执行import sys语句的时候，它在sys.path变量中所列目录中寻找sys.py模块。如果找到
了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你使用.初
始化过程仅在我们第一次输入模块的时候进行.脚本的名称总是sys.argv列表的第一个参数.
sys.path包含输入模块的目录名列表。我们可以观察到sys.path的第一个字符串是空的,这个
空的字符串表示当前目录也是sys.path的一部分，这与PYTHONPATH环境变量是相同的。这意
味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在sys.path所列的目录之
一。&lt;/p&gt;

&lt;h3 id=&#34;字节编译的-pyc文件&#34;&gt;字节编译的.pyc文件&lt;/h3&gt;

&lt;p&gt;输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更
加快一些。一种方法是创建字节编译的文件,这些文件以.pyc作为扩展名。字节编译的文件与
Python变换程序的中间状态有关,当你在下次从别的程序输入这个模块的时候,.pyc文件是十分有用的——它会快得多,因为一部分输入模块所需
的处理已经完成了,这些字节编译的文件也是与平台无关的。&lt;/p&gt;

&lt;h3 id=&#34;from-import&#34;&gt;from..import&lt;/h3&gt;

&lt;p&gt;如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用
from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys
import *语句。这对于所有模块都适用。一般说来，应该避免使用from..import而使用import语
句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。&lt;/p&gt;

&lt;h3 id=&#34;模块的-name&#34;&gt;模块的&lt;code&gt;__name__&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;python 模块有它的&lt;code&gt;__name__&lt;/code&gt;，如果是&lt;code&gt;__main__&lt;/code&gt;，说明被单独运行。&lt;/p&gt;

&lt;h3 id=&#34;制造自己模块&#34;&gt;制造自己模块&lt;/h3&gt;

&lt;p&gt;模块放在输入它的程序同一个目录或者sys.path之一。&lt;/p&gt;

&lt;h3 id=&#34;dir-函数&#34;&gt;dir()函数&lt;/h3&gt;

&lt;p&gt;你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。
当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当
前模块中定义的名称列表。&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;3种内建数据结构，列表，元组，字典&lt;/li&gt;
&lt;li&gt;列表，逗号分隔，可添加，删除，搜索，相当于链表[&amp;lsquo;apple&amp;rsquo;,&amp;lsquo;mac&amp;rsquo;]&lt;/li&gt;
&lt;li&gt;for..in用来遍历序列，del删除元素&lt;/li&gt;
&lt;li&gt;元组和列表类似，但是不能修改，相当于数组(&amp;lsquo;Java&amp;rsquo;,&amp;lsquo;Python&amp;rsquo;)&lt;/li&gt;
&lt;li&gt;元组最通常用在打印中&lt;code&gt;print &#39;%s is %d years old&#39; % (name, age)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字典相当于Map，键值对{key:value,key1:value1} 无序，想要顺序，使用前排序&lt;/li&gt;
&lt;li&gt;in检验键值是否存在，或者使用dict类的has_key，items()返回元组列表，每个元组包含一对项目，键值对&lt;/li&gt;
&lt;li&gt;列表，元组，字符串都是序列，具有索引和切片操作，索引获取特定项目，切片获取序列一部分&lt;/li&gt;
&lt;li&gt;索引负数表示从序列结尾计算，apple[-1]表示最后一个元素&lt;/li&gt;
&lt;li&gt;切片是序列名后跟方括号，方括号中一对可选数字，冒号分隔，数可选，冒号必须&lt;/li&gt;
&lt;li&gt;第一个数字开始位置，第二个数结束位置，不指定第一个数，从序列首开始，不指定第二个参数，序列尾结束，开始位置包含在切片，结束位置不包含&lt;/li&gt;
&lt;li&gt;注意引用，复制列表或者类似的序列，使用切片操作取得拷贝&lt;/li&gt;
&lt;li&gt;列表赋值不是创建拷贝，需要使用切片建立序列拷贝&lt;/li&gt;
&lt;li&gt;字符串方法 &lt;code&gt;&amp;quot;apple&amp;quot;.startswith(&amp;quot;a&amp;quot;)==True,&#39;a&#39; in &amp;quot;apple&amp;quot;==True,&amp;quot;apple&amp;quot;.find(a)==0,&amp;quot;-&amp;quot;.join([&amp;quot;Hello&amp;quot;,&amp;quot;World&amp;quot;])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编写python脚本&#34;&gt;编写Python脚本&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: backup_ver4.py
import os
import time
# 1. The files and directories to be backed up are specified in a list.
source = [&#39;/home/swaroop/byte&#39;, &#39;/home/swaroop/bin&#39;]
# If you are using Windows, use source = [r&#39;C:\Documents&#39;, r&#39;D:\Work&#39;] or something like that
# 2. The backup must be stored in a main backup directory
target_dir = &#39;/mnt/e/backup/&#39; # Remember to change this to what you will be using
# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory in the main directory
today = target_dir + time.strftime(&#39;%Y%m%d&#39;)
# The current time is the name of the zip archive
now = time.strftime(&#39;%H%M%S&#39;)
# Take a comment from the user to create the name of the zip file
comment = raw_input(&#39;Enter a comment --&amp;gt; &#39;)
if len(comment) == 0: # check if a comment was entered
target = today + os.sep + now + &#39;.zip&#39;
else:
target = today + os.sep + now + &#39;_&#39; + \
comment.replace(&#39; &#39;, &#39;_&#39;) + &#39;.zip&#39;
# Notice the backslash!
# Create the subdirectory if it isn&#39;t already there
if not os.path.exists(today):
os.mkdir(today) # make directory
print &#39;Successfully created directory&#39;, today
# 5. We use the zip command (in Unix/Linux) to put the files in a zip archive
zip_command = &amp;quot;zip -qr &#39;%s&#39; %s&amp;quot; % (target, &#39; &#39;.join(source))
# Run the backup
if os.system(zip_command) == 0:
print &#39;Successful backup to&#39;, target
else:
print &#39;Backup FAILED&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;面向对象编程&#34;&gt;面向对象编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;成员变量叫域，成员方法叫类的方法,域分为实例变量和类变量&lt;/li&gt;
&lt;li&gt;class 关键字创建，域和方法在一个缩进块中&lt;/li&gt;
&lt;li&gt;类方法和函数只有一个区别，必须有额外第一个参数名称，调用不用赋值，python自动赋值，对象本身self&lt;/li&gt;
&lt;li&gt;self相当于this&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.method(arg1,arg2) class.method(obj,arg1,arg2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__init__&lt;/code&gt;相当于constructor&lt;/li&gt;
&lt;li&gt;类变量所有实例共享，对象变量对象私有，self变量参考对象变量和方法，称为属性参考&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__&lt;/code&gt;相当于析构函数&lt;/li&gt;
&lt;li&gt;所有类成员，数据成员和方法都是public的，双下划线前缀为private&lt;/li&gt;
&lt;li&gt;惯例 只想在类或对象中使用，单下划线前缀&lt;/li&gt;
&lt;li&gt;继承 基本诶名称作为元组跟在定义类名称之后，基本类的&lt;code&gt;__init__&lt;/code&gt;使用self调用，这样就可以初始化对象的基本类部分，python不会自动调用基本类的constructor&lt;/li&gt;
&lt;li&gt;继承元组中使用一个以上的类称作多重继承&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;输入输出&#34;&gt;输入输出&lt;/h2&gt;

&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;

&lt;p&gt;使用File类的read，readline和write方法读写文件，对文件的读写能力依赖于开发文件的模式，完成文件操作，调用close&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: using_file.py
poem = &#39;&#39;&#39;\
Programming is fun
When the work is done
if you wanna make your work also fun:
use Python!
&#39;&#39;&#39;
f = file(&#39;poem.txt&#39;, &#39;w&#39;) # open for &#39;w&#39;riting
f.write(poem) # write text to file
f.close() # close the file
f = file(&#39;poem.txt&#39;)
# if no mode is specified, &#39;r&#39;ead mode is assumed by default
while True:
line = f.readline()
if len(line) == 0: # Zero length indicates EOF
break
print line,
# Notice comma to avoid automatic newline added by Python
f.close() # close the file
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;r读模式，w写模式，a追加模式&lt;/li&gt;
&lt;li&gt;len(f.readline())==0 indicates EOF&lt;/li&gt;
&lt;li&gt;,消除换行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;存储器&#34;&gt;存储器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Python标准模块，称为pickle，在文件中存储Python对象，之后可以取出来。相当于Java中的持久化&lt;/li&gt;
&lt;li&gt;cPickle功能一致，用c编写的，更快&lt;/li&gt;
&lt;li&gt;import..as 可以使用更短模块名称&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: pickling.py
import cPickle as p
#import pickle as p
shoplistfile = &#39;shoplist.data&#39;
# the name of the file where we will store the object
shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;]
# Write to the file
f = file(shoplistfile, &#39;w&#39;)
p.dump(shoplist, f) # dump the object to a file
f.close()
del shoplist # remove the shoplist
# Read back from the storage
f = file(shoplistfile)
storedlist = p.load(f)
print storedlist
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;异常&#34;&gt;异常&lt;/h2&gt;

&lt;h3 id=&#34;try-except&#34;&gt;try..except&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: try_except.py
import sys
try:
s = raw_input(&#39;Enter something --&amp;gt; &#39;)
except EOFError:
print &#39;\nWhy did you do an EOF on me?&#39;
sys.exit() # exit the program
except:
print &#39;\nSome error/exception occurred.&#39;
# here, we are not exiting the program
print &#39;Done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try..except相当于Java中的try exception&lt;/li&gt;
&lt;li&gt;可以接else语句，没有异常时执行&lt;/li&gt;
&lt;li&gt;raise引发异常，相当于throw，指明名称和异常对象，Error或者Exception的子类&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: raising.py
class ShortInputException(Exception):
&#39;&#39;&#39;A user-defined exception class.&#39;&#39;&#39;
def __init__(self, length, atleast):
Exception.__init__(self)
self.length = length
self.atleast = atleast
try:
s = raw_input(&#39;Enter something --&amp;gt; &#39;)
if len(s) &amp;lt; 3:
raise ShortInputException(len(s), 3)
# Other work can continue as usual here
except EOFError:
print &#39;\nWhy did you do an EOF on me?&#39;
except ShortInputException, x:
print &#39;ShortInputException: The input was of length %d, \
was expecting at least %d&#39; % (x.length, x.atleast)
else:
print &#39;No exception was raised.&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;try-finally&#34;&gt;try..finally&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: finally.py
import time
try:
f = file(&#39;poem.txt&#39;)
while True: # our usual file-reading idiom
line = f.readline()
if len(line) == 0:
break
time.sleep(2)
print line,
finally:
f.close()
print &#39;Cleaning up...closed the file&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python标准库&#34;&gt;Python标准库&lt;/h2&gt;

&lt;h3 id=&#34;sys模块&#34;&gt;sys模块&lt;/h3&gt;

&lt;p&gt;sys模块包含系统对应功能, sys.stdin,sys.stdout,sys.stderr对应标准输入，输出，错误流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: cat.py
import sys
def readfile(filename):
&#39;&#39;&#39;Print a file to the standard output.&#39;&#39;&#39;
f = file(filename)
while True:
line = f.readline()
if len(line) == 0:
break
print line, # notice comma
f.close()
# Script starts from here
if len(sys.argv) &amp;lt; 2:
print &#39;No action specified.&#39;
sys.exit()
if sys.argv[1].startswith(&#39;--&#39;):
option = sys.argv[1][2:]
# fetch sys.argv[1] but without the first two characters
if option == &#39;version&#39;:
print &#39;Version 1.2&#39;
elif option == &#39;help&#39;:
print &#39;&#39;&#39;\
This program prints files to the standard output.
Any number of files can be specified.
Options include:
--version : Prints the version number
--help : Display this help&#39;&#39;&#39;
else:
print &#39;Unknown option.&#39;
sys.exit()
else:
for filename in sys.argv[1:]:
readfile(filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os模块&#34;&gt;os模块&lt;/h3&gt;

&lt;p&gt;包含普遍操作系统功能，对平台无关很重要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;os.name windows-&amp;gt;nt,linux/unix-&amp;gt;posix&lt;/li&gt;
&lt;li&gt;os.getcwd() 当前工作目录&lt;/li&gt;
&lt;li&gt;os.getenv(),os.putenv()读取和设置环境变量&lt;/li&gt;
&lt;li&gt;os.listdir()返回指定目录下的所有文件和目录名&lt;/li&gt;
&lt;li&gt;os.remove()删除文件&lt;/li&gt;
&lt;li&gt;os.system()运行shell命令&lt;/li&gt;
&lt;li&gt;os.linesep当前平台终止符&lt;/li&gt;
&lt;li&gt;os.path.split()返回目录名和文件名&lt;code&gt;os.path.split(&#39;/home/apple.txt&#39;)-&amp;gt;(&#39;/home&#39;,&#39;apple.txt&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;os.path.isfile() os.path.isdir()判断文件和路径&lt;/li&gt;
&lt;li&gt;os.path.exists()判断路径是否存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;更多python内容&#34;&gt;更多Python内容&lt;/h2&gt;

&lt;h3 id=&#34;特殊方法&#34;&gt;特殊方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__(self...)&lt;/code&gt; 新建对象调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__(self)&lt;/code&gt; 删除对象调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__str__(self)&lt;/code&gt; print语句或者str()调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__lt__(self,other)&lt;/code&gt; 运算符&amp;lt;调用，类似+&amp;gt;都有特殊方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__getitem__(self,key)&lt;/code&gt;使用x[key]索引操作符调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__len(self)__&lt;/code&gt;内建len()函数调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;单语句块&#34;&gt;单语句块&lt;/h3&gt;

&lt;p&gt;语句块只包含一句，可以在条件或者循环语句同一行指明&lt;/p&gt;

&lt;h3 id=&#34;列表综合&#34;&gt;列表综合&lt;/h3&gt;

&lt;p&gt;从已有列表导出一个新的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: list_comprehension.py
listone = [2, 3, 4]
listtwo = [2*i for i in listone if i &amp;gt; 2]
print listtwo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数中接收元组和列表&#34;&gt;函数中接收元组和列表&lt;/h3&gt;

&lt;p&gt;使用函数接受元组或者字典参数，可以加*和**前缀
由于args变量前有*前缀，多余参数会作为元组存储在args上，如果使用的是**前缀，多余参数被认为是字典的键值对&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def powersum(power, *args):
... &#39;&#39;&#39;Return the sum of each argument raised to specified power.&#39;&#39;&#39;
... total = 0
... for i in args:
... total += pow(i, power)
... return total
...
&amp;gt;&amp;gt;&amp;gt; powersum(2, 3, 4)
25
&amp;gt;&amp;gt;&amp;gt; powersum(2, 10)
100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lambda形式&#34;&gt;lambda形式&lt;/h3&gt;

&lt;p&gt;lambda用来创建新的函数对象，运行时返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# Filename: lambda.py
def make_repeater(n):
return lambda s: s*n
twice = make_repeater(2)
print twice(&#39;word&#39;)
print twice(5)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exec-和-eval&#34;&gt;exec 和 eval&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;exec用来执行字符串或者文件中的python语句&lt;/li&gt;
&lt;li&gt;eval 用来计算存储在字符串中的有效python表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;assert&#34;&gt;assert&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;和Java类似，assert验证某个条件为真，如果为假，触发AssertError&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;repr函数&#34;&gt;repr函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;取得对象的规范字符串表示，`完成相同功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接下来学什么&#34;&gt;接下来学什么&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Python标准库是一个丰富的库，在大多数时候，你可以在这个库中找到你所需的东西。
这被称为Python的“功能齐全”理念。我强烈建议你在开始开发大型Python程序之前浏
览一下Python标准文档。&lt;/li&gt;
&lt;li&gt;Python.org——Python编程语言的官方主页。你可以在上面找到Python语言和解释器的最
新版本。另外还有各种邮件列表活跃地讨论Python的各方面内容。&lt;/li&gt;
&lt;li&gt;comp.lang.python是讨论Python语言的世界性新闻组。你可以把你的疑惑和询问贴在这个
新闻组上。可以使用Google群在线访问这个新闻组，或加入作为新闻组镜像的邮件列
表。&lt;/li&gt;
&lt;li&gt;《Python实用大全》是一个极有价值的秘诀和技巧集合，它帮助你解决某些使用Python
的问题。这是每个Python用户必读的一本书。&lt;/li&gt;
&lt;li&gt;《迷人的Python》是David Mertz编著的一系列优秀的Python相关文章。&lt;/li&gt;
&lt;li&gt;《深入理解Python》是给有经验的Python程序员的一本很优秀的书。如果你已经完整地
阅读了本书，那么我强烈建议你接下来阅读《深入理解Python》。它覆盖了包括XML处
理、单元测试和功能性编程在内的广泛的主题。&lt;/li&gt;
&lt;li&gt;Jython是用Java语言实现的Python解释器。这意味着你可以用Python语言编写程序而同时
使用Java库！Jython是一个稳定成熟的软件。如果你也是一个Java程序员，我强烈建议你
尝试一下Jython。&lt;/li&gt;
&lt;li&gt;IronPython是用C#语言实现的Python解释器，可以运行在.NET、Mono和DotGNU平台
上。这意味着你可以用Python语言编写程序而使用.NET库以及其他由这三种平台提供的
库！IronPython还只是一个前期alpha测试软件，现在还只适合用来进行试验。Jim
Hugunin，IronPython的开发者，已经加入了微软公司，将在将来全力开发一个完整版本
的IronPython。&lt;/li&gt;
&lt;li&gt;Lython是Python语言的Lisp前段。它类似于普通的Lisp语言，会被直接编译为Python字节码，这意味着它能与我们普通的Python代码协同工作。&lt;/li&gt;
&lt;li&gt;另外还有很多很多的Python资源。其中比较有趣的有Daily Python-URL!，它使你保持与Python的最新进展同步。另外还有Vaults of Parnassus、ONLamp.com Python DevCenter、dirtSimple.org、Python Notes等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;《Python简明教程》&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdown Basic</title>
      <link>https://crazymole.github.io/post/Markdown-Basic/</link>
      <pubDate>Thu, 17 Mar 2016 09:24:23 -0400</pubDate>
      
      <guid>https://crazymole.github.io/post/Markdown-Basic/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，创始人为約翰·格魯伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[3]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上摘自维基百科，既然你已经看到了这篇文章，就不用过多介绍Markdown了
&lt;a href=&#34;https://daringfireball.net/projects/markdown/basics&#34;&gt;John Gruber&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;标题&#34;&gt;标题&lt;/h2&gt;

&lt;p&gt;标题前输入多个#对应级别的HTML标题，h1和h2可在标题的下一行加任意数量=或-实现&lt;/p&gt;

&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;

&lt;h1 id=&#34;标题1&#34;&gt;标题1&lt;/h1&gt;

&lt;h3 id=&#34;标题3&#34;&gt;标题3&lt;/h3&gt;

&lt;h6 id=&#34;标题6&#34;&gt;标题6&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;一级标题
===================
二级标题
--------------------
# 标题1
### 标题3
###### 标题6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;粗体-斜体&#34;&gt;粗体/斜体&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;我是粗体&lt;/strong&gt;
&lt;em&gt;我是斜体&lt;/em&gt;
&lt;strong&gt;&lt;em&gt;我是粗斜体&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;**我是粗体**
_我是斜体_
**_我是粗斜体_**
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引用&#34;&gt;引用&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;My life for AIUR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; My life for AIUR
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分割线&#34;&gt;分割线&lt;/h2&gt;

&lt;p&gt;3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;* * *
***
*****
- - -
---------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;无序列表&#34;&gt;无序列表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;项目1&lt;/li&gt;
&lt;li&gt;项目2

&lt;ul&gt;
&lt;li&gt;项目3&lt;/li&gt;
&lt;li&gt;项目4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;* 项目1
* 项目2
  - 项目3
  + 项目4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;有序列表&#34;&gt;有序列表&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;项目1&lt;/li&gt;
&lt;li&gt;项目2

&lt;ul&gt;
&lt;li&gt;项目3&lt;/li&gt;
&lt;li&gt;项目4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;1. 项目1
1. 项目2
	* 项目3
	* 项目4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;图片&#34;&gt;图片&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://crazymole.github.io/img/avatar.jpg&#34; alt=&#34;alt信息&#34; title=&#34;标题&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![alt信息](/img/avatar.jpg &amp;quot;标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com&#34; title=&#34;Go to github&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[链接文字](链接地址 标题)
[GitHub](http://github.com &amp;quot;Go to github&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;索引链接&#34;&gt;索引链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://google.com&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt;
&lt;a href=&#34;http://search.yahoo.com&#34; title=&#34;Yahoo serach&#34;&gt;Yahoo&lt;/a&gt;
&lt;img src=&#34;https://crazymole.github.io/img/avatar.jpg&#34; alt=&#34;mole&#34; title=&#34;mole&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[链接文字][索引id]
`[索引id]:索引地址 标题`

[Google][g]
[Yahoo][y]
![mole][m]

`[g]:http://google.com &amp;quot;Google&amp;quot;`
`[y]:http://search.yahoo.com &amp;quot;Yahoo serach&amp;quot;`
`[m]:/img/avatar.jpg &amp;quot;mole&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自动链接&#34;&gt;自动链接&lt;/h2&gt;

&lt;p&gt;尖括号或者直接输入地址&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://google.com&#34;&gt;http://google.com&lt;/a&gt;
&lt;code&gt;&amp;lt;http://google.com&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;行内代码&#34;&gt;行内代码&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;System.out.println(&amp;quot;Hello World&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;`System.out.println(&amp;ldquo;Hello World&amp;rdquo;);`&lt;/p&gt;

&lt;h2 id=&#34;多行代码&#34;&gt;多行代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;	```
	public static void main(String args[]){
		System.out.println(&amp;quot;Hello World&amp;quot;);
	}
	```
	或者4个空格或者1个Tab
	public static void main(String args[]){
		System.out.println(&amp;quot;Hello World&amp;quot;);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;转义符&#34;&gt;转义符&lt;/h2&gt;

&lt;p&gt;\ 反斜杠
` 反引号
* 星号
_ 下划线
{} 大括号
[] 中括号
() 小括号
# 井号
+ 加号
- 减号
. 英文句号
! 感叹号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\ 反斜杠
\` 反引号
\* 星号
\_ 下划线
\{\} 大括号
\[\] 中括号
\(\) 小括号
\# 井号
\+ 加号
\- 减号
\. 英文句号
\! 感叹号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;表格&#34;&gt;表格&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Are&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Cool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col 1 is&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;left-aligned&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;$1600&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;col 2 is&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;centered&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;$12&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;col 3 is&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;right-aligned&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;$1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;可以写HTML，前后加空行&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://daringfireball.net/projects/markdown/basics&#34;&gt;https://daringfireball.net/projects/markdown/basics&lt;/a&gt;
&lt;a href=&#34;http://ibruce.info/2013/11/26/markdown/&#34;&gt;http://ibruce.info/2013/11/26/markdown/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Number of Digit One</title>
      <link>https://crazymole.github.io/post/Number-of-Digit-One/</link>
      <pubDate>Thu, 04 Feb 2016 00:17:36 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Number-of-Digit-One/</guid>
      <description>&lt;p&gt;Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public int countDigitOne(int n) {
        long count=0;
        long factor=1;
        while(n/factor!=0){
            long high=n/factor/10;
            long low=n%factor;
            long cur=n/factor%10;
            if(cur&amp;gt;=2){
                count+=(high+1)*factor;
            }else if(cur==1){
                count+=high*factor;
                count+=low+1;
            }else{
                count+=high*factor;
            }
            factor*=10;
        }
        return (int)count;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>https://crazymole.github.io/post/Longest-Palindromic-Substring/</link>
      <pubDate>Thu, 04 Feb 2016 00:17:00 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Longest-Palindromic-Substring/</guid>
      <description>&lt;p&gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public String longestPalindrome(String s) {
        if(s==null||s.equals(&amp;quot;&amp;quot;)){
            return &amp;quot;&amp;quot;;
        }
        String p=expendPalindrome(s,0,0);
        for(int i=0;i&amp;lt;s.length();i++){
            String p1=expendPalindrome(s,i,i);
            if(p1.length()&amp;gt;p.length()){
                p=p1;
            }
            String p2=expendPalindrome(s,i,i+1);
            if(p2.length()&amp;gt;p.length()){
                p=p2;
            }
        }
        return p;
    }
    public String expendPalindrome(String s,int l,int r){
        int n=s.length();
        while(l&amp;gt;=0&amp;amp;&amp;amp;r&amp;lt;=n-1&amp;amp;&amp;amp;s.charAt(l)==s.charAt(r)){
            l--;
            r++;
        }
        return s.substring(l+1,r);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Range Sum Query 2D Immutable</title>
      <link>https://crazymole.github.io/post/Range-Sum-Query-2D-Immutable/</link>
      <pubDate>Thu, 04 Feb 2016 00:16:24 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Range-Sum-Query-2D-Immutable/</guid>
      <description>&lt;p&gt;Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).&lt;/p&gt;

&lt;p&gt;The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&amp;gt; 8
sumRegion(1, 1, 2, 2) -&amp;gt; 11
sumRegion(1, 2, 2, 4) -&amp;gt; 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You may assume that the matrix does not change.&lt;/li&gt;
&lt;li&gt;There are many calls to sumRegion function.&lt;/li&gt;
&lt;li&gt;You may assume that row1 ≤ row2 and col1 ≤ col2.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;public class NumMatrix {
    int[][] p=null;
    public NumMatrix(int[][] matrix) {
        int n=matrix.length;
        if(n==0){
            return;
        }
        int m=matrix[0].length;
        if(m==0){
            return;
        }
        p=new int[n+1][m+1];
        for(int i=0;i&amp;lt;=n;i++){
            p[i][0]=0;
        }
        for(int i=0;i&amp;lt;=m;i++){
            p[0][i]=0;
        }
        for(int i=1;i&amp;lt;=n;i++){
            for(int j=1;j&amp;lt;=m;j++){
                p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+matrix[i-1][j-1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        if(p==null){
            return 0;
        }
        return p[row2+1][col2+1]-p[row2+1][col1]-p[row1][col2+1]+p[row1][col1];
    }
}


// Your NumMatrix object will be instantiated and called as such:
// NumMatrix numMatrix = new NumMatrix(matrix);
// numMatrix.sumRegion(0, 1, 2, 3);
// numMatrix.sumRegion(1, 2, 3, 4);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse Words in a String</title>
      <link>https://crazymole.github.io/post/Reverse-Words-in-a-String/</link>
      <pubDate>Thu, 04 Feb 2016 00:15:13 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Reverse-Words-in-a-String/</guid>
      <description>&lt;p&gt;Given an input string, reverse the string word by word.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;the sky is blue&amp;quot;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;return &lt;code&gt;&amp;quot;blue is sky the&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Update (2015-02-12):
For C programmers: Try to solve it in-place in O(1) space.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Clarification:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What constitutes a word?

&lt;ul&gt;
&lt;li&gt;A sequence of non-space characters constitutes a word.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Could the input string contain leading or trailing spaces?

&lt;ul&gt;
&lt;li&gt;Yes. However, your reversed string should not contain leading or trailing spaces.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;How about multiple spaces between two words?

&lt;ul&gt;
&lt;li&gt;Reduce them to a single space in the reversed string.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public String reverseWords(String s) {
        String[] arr=s.split(&amp;quot; &amp;quot;);
        StringBuilder sb=new StringBuilder();
        for(int i=arr.length-1;i&amp;gt;=0;i--){
            if(!arr[i].trim().equals(&amp;quot;&amp;quot;)){
                if(sb.length()!=0){
                    sb.append(&amp;quot; &amp;quot;);
                }
                sb.append(arr[i]);
            }
        }
        return sb.toString();
    }
    public String reverse(String s){
        if(s!=null){
            char[] ch=s.toCharArray();
            int l=0,r=ch.length-1;
            while(l&amp;lt;r){
                char c=ch[l];
                ch[l]=ch[r];
                ch[r]=c;
                l++;
                r--;
            }
            return new String(ch,0,ch.length);
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Surrounded Regions</title>
      <link>https://crazymole.github.io/post/Surrounded-Regions/</link>
      <pubDate>Thu, 04 Feb 2016 00:13:52 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Surrounded-Regions/</guid>
      <description>&lt;p&gt;Given a 2D board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions surrounded by &amp;lsquo;X&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X O O X
X X O X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the board should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X X X X
X X X X
X O X X
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public void solve(char[][] board) {
        //left top to right down
        int n=board.length;
        if(n==0){
            return;
        }
        int m=board[0].length;
        if(n&amp;lt;=2||m&amp;lt;=2){
            return;
        }
        for(int i=0;i&amp;lt;n;i++){
            if(board[i][0]==&#39;O&#39;){
                board[i][0]=&#39;P&#39;;
            }
            if(board[i][m-1]==&#39;O&#39;){
                board[i][m-1]=&#39;P&#39;;
            }
        }
        for(int i=0;i&amp;lt;m;i++){
            if(board[0][i]==&#39;O&#39;){
                board[0][i]=&#39;P&#39;;
            }
            if(board[n-1][i]==&#39;O&#39;){
                board[n-1][i]=&#39;P&#39;;
            }
        }
        for(int i=1;i&amp;lt;n-1;i++){
            trigger(board,i,1);
            trigger(board,i,m-2);
        }
        for(int i=1;i&amp;lt;m-1;i++){
            trigger(board,1,i);
            trigger(board,n-2,i);
        }
        for(int i=0;i&amp;lt;n;i++){
            for(int j=0;j&amp;lt;m;j++){
                if(board[i][j]==&#39;O&#39;){
                    board[i][j]=&#39;X&#39;;
                }else if(board[i][j]==&#39;P&#39;){
                    board[i][j]=&#39;O&#39;;
                }
            }
        }
        
    }
    public void trigger(char[][] board,int i,int j){
        int n=board.length;
        int m=board[0].length;
        if(board[i][j]==&#39;O&#39;){
            if(board[i][j-1]==&#39;P&#39;||board[i][j+1]==&#39;P&#39;||board[i-1][j]==&#39;P&#39;||board[i+1][j]==&#39;P&#39;){
                board[i][j]=&#39;P&#39;;
                trigger(board,i+1,j);
                trigger(board,i-1,j);
                trigger(board,i,j+1);
                trigger(board,i,j-1);
            }
        }
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Inter to English Words</title>
      <link>https://crazymole.github.io/post/Integer-to-English-Words/</link>
      <pubDate>Wed, 03 Feb 2016 22:28:08 -0500</pubDate>
      
      <guid>https://crazymole.github.io/post/Integer-to-English-Words/</guid>
      <description>&lt;p&gt;Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;123 -&amp;gt; &lt;code&gt;&amp;quot;One Hundred Twenty Three&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;12345 -&amp;gt; &lt;code&gt;&amp;quot;Twelve Thousand Three Hundred Forty Five&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1234567 -&amp;gt; &lt;code&gt;&amp;quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    //0-19的字典
    private String[] dic_0_19={&amp;quot;&amp;quot;, &amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;, &amp;quot;Four&amp;quot;, &amp;quot;Five&amp;quot;, &amp;quot;Six&amp;quot;, &amp;quot;Seven&amp;quot;, &amp;quot;Eight&amp;quot;, &amp;quot;Nine&amp;quot;, &amp;quot;Ten&amp;quot;, &amp;quot;Eleven&amp;quot;, &amp;quot;Twelve&amp;quot;, &amp;quot;Thirteen&amp;quot;, &amp;quot;Fourteen&amp;quot;, &amp;quot;Fifteen&amp;quot;, &amp;quot;Sixteen&amp;quot;, &amp;quot;Seventeen&amp;quot;, &amp;quot;Eighteen&amp;quot;, &amp;quot;Nineteen&amp;quot;};
    //20-90之间整十位的字典
    private String[] dic_20_90={&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Twenty&amp;quot;, &amp;quot;Thirty&amp;quot;, &amp;quot;Forty&amp;quot;, &amp;quot;Fifty&amp;quot;, &amp;quot;Sixty&amp;quot;, &amp;quot;Seventy&amp;quot;, &amp;quot;Eighty&amp;quot;, &amp;quot;Ninety&amp;quot;};
    //大数位字典
    private String[] big={&amp;quot;Thousand&amp;quot;,&amp;quot;Million&amp;quot;,&amp;quot;Billion&amp;quot;};
    public String numberToWords(int num) {
        //百位
        String res=convertHundred(num%1000);
        //千，百万，十亿
        for(int i=0;i&amp;lt;3;i++){
            num=num/1000;
            if(num%1000&amp;gt;0){
                String leftStr=convertHundred(num%1000)+&amp;quot; &amp;quot;+big[i];
                //处理空格
                if(res.length()!=0){
                    res=leftStr+&amp;quot; &amp;quot;+res;
                }else{
                    res=leftStr;
                }
            }
        }
        return res.length()==0?&amp;quot;Zero&amp;quot;:res;
    }
    
    //返回小于1000的结果
    public String convertHundred(int num){
        StringBuilder sb=new StringBuilder();
        int huns=num/100;
        int ten=num%100;
        int tens=ten/10;
        int digit=ten%10;
        
        String hundredStr,tenStr,digitStr;
        if(huns&amp;gt;0){
            sb.append(dic_0_19[huns]).append(&amp;quot; &amp;quot;).append(&amp;quot;Hundred&amp;quot;);
        }
        if(ten&amp;gt;0){
            if(huns&amp;gt;0){
                sb.append(&amp;quot; &amp;quot;);
            }
            if(ten&amp;lt;20){
                sb.append(dic_0_19[ten]);
            }else{
                if(tens&amp;gt;0){
                    sb.append(dic_20_90[tens]);
                }
                if(digit&amp;gt;0){
                    if(tens&amp;gt;0){
                        sb.append(&amp;quot; &amp;quot;);
                    }
                    sb.append(dic_0_19[digit]);
                }
                
            }
        }
        return sb.toString();
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>